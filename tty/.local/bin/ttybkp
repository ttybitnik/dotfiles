#!/bin/sh

# Naming standard for backups (ISO 8601).
#   Dependencies:
#     /usr/local/lib/tty.sh

. /usr/local/lib/tty.sh

# OPT(uname): s={kernel,system}-name
case $(uname -s) in
    FreeBSD*|OpenBSD*|NetBSD*|Darwin*)
	# OPT(date): r=reference-time
	_date0() { date -r "$1" "+%Y%m%dT%H%M%S"; }
	# OPT(stat): f=format
	_stat0() { stat -f %m "$1"; }
	;;
    *)
	# OPT(date): d=date
	_date0() { date -d "@$1" "+%Y%m%dT%H%M%S"; }
	# OPT(stat): c=format
	_stat0() { stat -c %Y "$1"; }
	;;
esac

sanitize_input() {
    # OPT(tr): c=complement d=delete
    printf "%s" "$1" \
	| tr ' ' '_' \
	| tr '[:upper:]' '[:lower:]' \
	| tr -cd '[:alnum:]_'
}

prompt_input() {
    printf "Enter elements separated by spaces if needed.\n"
    printf "Technology name: "
    # OPT(read): r=no-backslashes
    read -r input_domain
    printf "Specific info: "
    # OPT(read): r=no-backslashes
    read -r input_scope

    domain=$(sanitize_input "$input_domain")
    scope=$(sanitize_input "$input_scope")
}

main() {
    prompt_input
    filename=$(basename -- "$1")
    extensions="${filename#*.}"
    modification_epoch=$(_stat0 "$1")
    modification_timestamp=$(_date0 "$modification_epoch")

    new_filename="${domain}_${scope}_${modification_timestamp}.${extensions}"

    mv "$1" "$new_filename"
    tty_info "%s: new file name: '%s'" "$(basename "$0")" "$new_filename"
}

if [ "$#" -ne 1 ]; then
    tty_fatal "%s: wrong number of arguments" "$(basename "$0")"
elif [ ! -f "$1" ]; then
    tty_fatal "%s: file not found: '%s'" "$(basename "$0")" "$1"
else
    main "$@"
fi
